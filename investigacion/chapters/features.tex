\chapter{Features}\label{ch:features}
One of the greatest challenges of \emph{Vulkan} is to offer a high hardware performance, with the lowest consumption
possible and reducing the overhead. Nowadays, mobile devices have the chance of running games with a great graphical
quality. One method that is employed is to reduce the use of the \gls{cpu}. This reduction is performed by a reduction
in the number of delegated tasks, instead the responsibility of the \gls{gpu} is increased: use of batch tasks in the
\gls{gpu}, exclusive use of the \gls{cpu} for rendering and computation.

Reaching to all devices is other of the main objectives. \emph{Vulkan LunarG} implementation is available from
\emph{Windows 7} to \emph{Windows 10}, \emph{Tizen}, \emph{GNU\/Linux} and \emph{Android}. The \gls{sdk} is can be
installed in both \emph{Windows} and \emph{GNU\/Linux} desktop environments. In \emph{MacOS} is being developed by
third parties for achieving the execution of Vulkan applications. \emph{The Brenwill Workshop} is a development company
specialized on graphics software. They have proposed to create a middleware between the \emph{OpenGL} and \emph{Metal}
\gls{api} implementations for getting the support of \emph{Vulkan} on \emph{MacOS} and \emph{iOS}. The solution
is called \emph{Molten}, and it is part of an available graphic development framework.

\emph{Vulkan} implements several improvements at technical level, which are a good reason for being the best successor
of \emph{OpenGL}:
\begin{itemize}
    \item Native muticore \gls{cpu}s scaling support.
    \item Use of intermediate binary format called \emph{SPIR-V}: \emph{Vulkan} generates its own code for generating
    shaders, so that the drivers do not require the development of a compiler for being able to render them. As the
    shaders are compiled, a higher range of shaders can be used per scene. The driver just is in charge of optimize
    and generate the final compiled code.
    \item Unified management of computing kernels and graphical shaders: both \gls{api} are mixed that, until now, were
    separated.
    \item Oriented to objects, there is no global state.
    \item States are not tied into a context, they are cached in a buffer.
    \item Multithreading support.
    \item More control over memory and synchronization.
\end{itemize}

There are features that have been proposed, but will be implemented in the future. For instance, providing support to
multiple \gls{gpu}s of different model. The need of using \gls{sli} for being able to use several graphical cards at
the same time.

On the Figure \ref{fig:comparison_opengl_vulkan} the existing differences between the two \gls{api} can be appreciated
more graphically. As you may notice among the features of \emph{Vulkan}, a closest access to the hardware from the
applications has been attempted. Thanks to this, the need of a huge error and memory management is removed. Only a
intermediate language is employed for using shaders (\emph{SPIR-V}), and the \gls{api} is the same for developing on
both mobile applications and desktop applications.

Knowing all these information could be concluded that \emph{Vulkan} increases the work load that the developers already
have. However, things are not as they appear. \emph{Vulkan} can be applied at three different levels:

\begin{enumerate}
    \item Use directly all these features for having a full control over the engine.
    \item Use and share libraries and layers for accelerating the development process.
    \item Use already existing and optimized engines over the \emph{Vulkan} \gls{api}.
\end{enumerate}

The first option is the less frequent since developers have to start from scratch. But it could be a good option for
making good benchmarks. \emph{Khronos} expects the second option to be a rich area of innovation among the community and
companies. As the libraries can be published as little bundles, they could be shared as Open Source that require
improvements and updates. The last option could be the most tentative considering that the hard work has already
done by industry giants, developers have only to pay some royalties to the propietaries of the engine; for instance
\emph{Unity Engine}.

On the Figure \ref{fig:vulkan_ecosystem} can be appreciated how the \emph{Vulkan} architecture is distributed. As
explained, the \emph{Vulkan} implementation is placed in a lower level that the game engine. It is located over the
hardware so that many of its features can be exploded directly. An interface is set up for implementing other tools
and frameworks joined together with \emph{Vulkan} in the future.

\begin{figure}[t]
	\begin{center}
		\includegraphics[scale=0.3]{comparison-opengl_and_vulkan}
		\caption{Features of \emph{OpenGL} and \emph{Vulkan} Comparison}
		\label{fig:comparison_opengl_vulkan}
	\end{center}
\end{figure}
\begin{figure}[t]
	\begin{center}
		\includegraphics[scale=0.3]{ecosystem-vulkan}
		\caption{\emph{Vulkan} Ecosystem}
		\label{fig:vulkan_ecosystem}
	\end{center}
\end{figure}
